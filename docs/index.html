<!DOCTYPE html>
<html>
<head>
    <title>Chussy Inferno 3D - Polski Edition</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
        }
        canvas { 
            grid-column: 2 / 12;
            grid-row: 2;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .flame-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .flame {
            position: absolute;
            font-size: 24px;
            animation: fall linear infinite;
        }
        @keyframes fall {
            from { transform: translateY(-20px); }
            to { transform: translateY(100vh); }
        }
        .game-title {
            grid-column: 1 / -1;
            grid-row: 1;
            text-align: center;
            color: #ff4400;
            font-size: 48px;
            text-shadow: 0 0 10px #ff0000;
            z-index: 2;
        }
        .minimap {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4400;
            z-index: 3;
        }
    .ceo-approval {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 2;
            text-align: center;
            color: #ff4400;
            text-shadow: 0 0 10px #ff0000;
        }
        .ceo-approval img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid #ff4400;
            box-shadow: 0 0 10px #ff0000;
        }
        .death-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #ff0000;
            padding: 40px;
            text-align: center;
            z-index: 1000;
            font-family: "Press Start 2P", monospace;
            box-shadow: 0 0 50px #ff0000;
        }
        .death-popup h2 {
            color: #ff0000;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #ff0000;
        }
        .death-popup button {
            background: #ff0000;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            font-family: "Press Start 2P", monospace;
            transition: all 0.3s;
        }
        .death-popup button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #ff0000;
        }
    </style>
</head>
<body>
    <h1 class="game-title">🔥 CHUSSY DEEZ PIEROGI INFERNO 3D 🔥</h1>
    <div class="flame-container" id="flameContainer"></div>
    <canvas id="gameCanvas"></canvas>
    <canvas id="minimapCanvas" class="minimap"></canvas>
    <div class="ceo-approval">
        <p>ThePrimeagen approves of this game</p>
        <img src="https://avatars.githubusercontent.com/u/4442245" alt="ThePrimeagen CEO">
    </div>
    <div class="death-popup" id="deathPopup">
        <h2>YOU DIED</h2>
        <button onclick="restartGame()">RESTART</button>
    </div>
    <script>
        // Key state tracking
        const keys = {
            w: false,
            s: false,
            a: false,
            d: false,
            ' ': false
        };

        // Game state
        const state = {
            projectiles: [],
            enemies: [],
            lastShot: 0,
            shootCooldown: 250, // milliseconds
            gameOver: false,
            player: {
                health: 100,
                maxHealth: 100
            },
            autoplay: {
                enabled: false,
                lastActivity: Date.now(),
                inactivityThreshold: 5000, // 5 seconds
                targetEnemy: null,
                nextMoveTime: 0,
                moveInterval: 1000, // Change direction every second
                lastPing: Date.now(),
                pingInterval: 300000 // 5 minutes in milliseconds
            },
            sounds: {
                ping: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU') // Discord ping sound
            }
        };

        // Map data
        const MAP = [
            [1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1],
            [1,0,1,0,0,1,0,1],
            [1,0,0,0,0,0,0,1],
            [1,0,1,0,0,1,0,1],
            [1,0,0,0,0,0,0,1],
            [1,0,1,0,0,1,0,1],
            [1,1,1,1,1,1,1,1]
        ];

        // Player state
        const player = {
            x: 1.5,
            y: 1.5,
            angle: 0,
            fov: Math.PI / 3,
            speed: 0.033,  // Reduced by a third as commanded
            arms: {
                swingOffset: 0,
                swingSpeed: 0.1
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Raycasting
        function castRay(rayAngle) {
            let rayX = player.x;
            let rayY = player.y;
            let rayDirX = Math.cos(rayAngle);
            let rayDirY = Math.sin(rayAngle);
            
            let distance = 0;
            while (distance < 20) {
                rayX += rayDirX * 0.1;
                rayY += rayDirY * 0.1;
                distance += 0.1;
                
                let mapX = Math.floor(rayX);
                let mapY = Math.floor(rayY);
                
                if (MAP[mapY] && MAP[mapY][mapX] === 1) {
                    return distance;
                }
            }
            return distance;
        }

        // Spawn enemies
        function spawnEnemy() {
            // Initialize enemies array if it doesn't exist
            if (!state.enemies || !Array.isArray(state.enemies)) {
                state.enemies = [];
            }
            
            // Find valid spawn location away from walls
            let x, y;
            do {
                const angle = Math.random() * Math.PI * 2;
                const distance = 5;
                x = player.x + Math.cos(angle) * distance;
                y = player.y + Math.sin(angle) * distance;
            } while (MAP[Math.floor(y)][Math.floor(x)] === 1);
            
            // Create enemy with health and position
            state.enemies.push({
                x: x,
                y: y,
                health: 100,
                type: 'chad',
                lastMove: Date.now()
            });
        }
        
        // Spawn enemies every 5 seconds if there are less than 5 enemies
        setInterval(() => {
            if (!state.enemies || !Array.isArray(state.enemies) || state.enemies.length < 5) {
                spawnEnemy();
            }
        }, 5000);

        // Shooting mechanics
        function shoot() {
            const now = Date.now();
            if (now - state.lastShot >= state.shootCooldown) {
                state.projectiles.push({
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    speed: 0.5
                });
                state.lastShot = now;
            }
        }

        // Update projectiles and enemies
        // Autoplay AI logic
        function updateAutoplay() {
            const now = Date.now();
            
            // Check for inactivity
            if (!state.autoplay.enabled && now - state.autoplay.lastActivity > state.autoplay.inactivityThreshold) {
                state.autoplay.enabled = true;
                console.log('Autoplay activated');
                // Play initial ping when autoplay activates
                state.sounds.ping.play().catch(e => console.log('Audio play failed:', e));
                state.autoplay.lastPing = now;
            }
            
            // Play ping sound every 5 minutes during autoplay
            if (state.autoplay.enabled && now - state.autoplay.lastPing >= state.autoplay.pingInterval) {
                state.sounds.ping.play().catch(e => console.log('Audio play failed:', e));
                state.autoplay.lastPing = now;
            }

            if (state.autoplay.enabled) {
                // Find nearest enemy
                let nearestEnemy = null;
                let minDist = Infinity;
                state.enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                state.autoplay.targetEnemy = nearestEnemy;

                // Change movement direction periodically
                if (now > state.autoplay.nextMoveTime) {
                    state.autoplay.nextMoveTime = now + state.autoplay.moveInterval;
                    // Random movement pattern
                    keys.w = Math.random() > 0.5;
                    keys.s = !keys.w;
                    keys.a = Math.random() > 0.5;
                    keys.d = !keys.a;
                }

                // Aim and shoot at nearest enemy
                if (nearestEnemy) {
                    const targetAngle = Math.atan2(nearestEnemy.y - player.y, nearestEnemy.x - player.x);
                    player.angle = targetAngle;
                    keys[' '] = true; // Always shoot when enemy in sight
                }
            }
        }

        function handlePlayerDeath() {
            // Show death popup
            const popup = document.getElementById('deathPopup');
            if (popup) {
                popup.style.display = 'block';
            }
            // Stop game loop
            state.gameOver = true;
        }

        function restartGame() {
            // Reset player
            state.player.health = state.player.maxHealth;
            state.player.x = 1.5;
            state.player.y = 1.5;
            state.player.angle = 0;
            
            // Clear enemies
            state.enemies = [];
            
            // Hide death popup
            const popup = document.getElementById('deathPopup');
            if (popup) {
                popup.style.display = 'none';
            }
            
            // Resume game
            state.gameOver = false;
            requestAnimationFrame(drawFrame);
        }

        function updateEntities() {
            // Don't update if game is over
            if (state.gameOver) return;
            
            // Update autoplay
            updateAutoplay();

            // Handle continuous movement
            if (keys.w) {
                const newX = player.x + Math.cos(player.angle) * player.speed;
                const newY = player.y + Math.sin(player.angle) * player.speed;
                // Check wall collision before moving
                if (!MAP[Math.floor(newY)][Math.floor(newX)]) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys.s) {
                const newX = player.x - Math.cos(player.angle) * player.speed;
                const newY = player.y - Math.sin(player.angle) * player.speed;
                // Check wall collision before moving
                if (!MAP[Math.floor(newY)][Math.floor(newX)]) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys.a) {
                player.angle -= 0.1;
            }
            if (keys.d) {
                player.angle += 0.1;
            }

            // Handle shooting
            if (keys[' ']) {
                shoot();
            }

            // Update projectiles
            for (let i = state.projectiles.length - 1; i >= 0; i--) {
                const proj = state.projectiles[i];
                proj.x += Math.cos(proj.angle) * proj.speed;
                proj.y += Math.sin(proj.angle) * proj.speed;
                
                // Check collision with walls
                if (MAP[Math.floor(proj.y)][Math.floor(proj.x)] === 1) {
                    state.projectiles.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = state.enemies.length - 1; j >= 0; j--) {
                    const enemy = state.enemies[j];
                    const dx = proj.x - enemy.x;
                    const dy = proj.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.5) {
                        enemy.health -= 50;
                        if (enemy.health <= 0) {
                            state.enemies.splice(j, 1);
                        }
                        state.projectiles.splice(i, 1);
                        break;
                    }
                }
            }

            // Update enemies and handle collision/damage
            if (!state.gameOver && state.enemies && Array.isArray(state.enemies)) {
                state.enemies.forEach(enemy => {
                    if (!enemy || typeof enemy.x !== 'number' || typeof enemy.y !== 'number') return;
                    
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Enemy movement with wall collision detection
                    if (dist > 0.1) {
                        const newX = enemy.x + (dx / dist) * 0.03;
                        const newY = enemy.y + (dy / dist) * 0.03;
                        
                        // Check for death on collision
                        if (dist < 0.5) {
                            state.player.health = Math.max(0, state.player.health - 0.5);
                            if (state.player.health <= 0) {
                                handlePlayerDeath();
                                return;
                            }
                        }
                    
                    // Check wall collision before moving
                    if (!MAP[Math.floor(newY)][Math.floor(newX)]) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
                
                // Damage player if too close
                if (dist < 0.5) {
                    state.player.health = Math.max(0, state.player.health - 0.5);
                    // Check for death
                    if (state.player.health <= 0) {
                        handlePlayerDeath();
                    }
                }
            });
        }

        function handlePlayerDeath() {
            // Show death popup
            const popup = document.getElementById('deathPopup');
            if (popup) {
                popup.style.display = 'block';
            }
            // Stop game loop
            state.gameOver = true;
        }

        function restartGame() {
            // Reset player
            state.player.health = state.player.maxHealth;
            state.player.x = 1.5;
            state.player.y = 1.5;
            state.player.angle = 0;
            
            // Clear enemies
            state.enemies = [];
            
            // Hide death popup
            const popup = document.getElementById('deathPopup');
            if (popup) {
                popup.style.display = 'none';
            }
            
            // Resume game
            state.gameOver = false;
            requestAnimationFrame(drawFrame);
        }


        function drawFrame() {
            // Don't update if game is over
            if (state.gameOver) return;
            
            // Clear canvas with dark background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw enemies FIRST so they're behind walls
            if (state.enemies && Array.isArray(state.enemies)) {
                state.enemies.forEach(enemy => {
                    if (!enemy || typeof enemy.x !== 'number' || typeof enemy.y !== 'number') return;
                    
                    // Calculate distance for scaling effects
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Pulsing glow effect
                    const pulseScale = 1 + Math.sin(Date.now() / 200) * 0.2;
                    const glowSize = 70 * pulseScale;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 40;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fill();
                    
                    // Draw targeting lines
                    ctx.beginPath();
                    ctx.moveTo(enemy.x - 50, enemy.y);
                    ctx.lineTo(enemy.x + 50, enemy.y);
                    ctx.moveTo(enemy.x, enemy.y - 50);
                    ctx.lineTo(enemy.x, enemy.y + 50);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw CHAD ARMS
                    const armWidth = 30;
                    const armLength = 80;
                    const flexAngle = Math.sin(Date.now() / 500) * 0.3; // Flexing animation
                    
                    // Left buff arm
                    ctx.save();
                    ctx.translate(enemy.x - 32, enemy.y);
                    ctx.rotate(-Math.PI/4 + flexAngle);
                    ctx.fillStyle = '#8B4513'; // Muscular brown color
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 4;
                    
                    // Bicep
                    ctx.beginPath();
                    ctx.ellipse(-20, 0, armWidth, armLength/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Forearm
                    ctx.beginPath();
                    ctx.ellipse(-40, armLength/2, armWidth-10, armLength/3, flexAngle, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    
                    // Right buff arm
                    ctx.save();
                    ctx.translate(enemy.x + 32, enemy.y);
                    ctx.rotate(Math.PI/4 - flexAngle);
                    
                    // Bicep
                    ctx.beginPath();
                    ctx.ellipse(20, 0, armWidth, armLength/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Forearm
                    ctx.beginPath();
                    ctx.ellipse(40, armLength/2, armWidth-10, armLength/3, -flexAngle, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    
                    // Draw enemy body with thick outline
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 6;
                    ctx.strokeRect(enemy.x - 32, enemy.y - 32, 64, 64);
                    ctx.fillStyle = '#ff4400';
                    ctx.fillRect(enemy.x - 32, enemy.y - 32, 64, 64);
                    
                    // Draw distance indicator with color coding and better visibility
                    const distanceText = `${Math.floor(distance)}px`;
                    // Color code based on distance
                    let indicatorColor;
                    if (distance < 200) {
                        indicatorColor = '#ff0000'; // Red for close
                    } else if (distance < 400) {
                        indicatorColor = '#ffff00'; // Yellow for medium
                    } else {
                        indicatorColor = '#00ff00'; // Green for far
                    }
                    
                    // Draw background for better readability
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(enemy.x - 50, enemy.y + 40, 100, 25);
                    
                    // Draw text with outline for better visibility
                    ctx.font = 'bold 16px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(distanceText, enemy.x, enemy.y + 55);
                    ctx.fillStyle = indicatorColor;
                    ctx.fillText(distanceText, enemy.x, enemy.y + 55);
                    
                    // Draw warning indicator for close enemies
                    if (distance < 200) {
                        const warningY = enemy.y + 20;
                        ctx.font = 'bold 14px "Press Start 2P"';
                        ctx.fillStyle = '#ff0000';
                        ctx.fillText('⚠️ DANGER!', enemy.x, warningY);
                    }
                });
            }
            
            // Draw walls
            const numRays = canvas.width;
            const rayStep = player.fov / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const rayAngle = player.angle - player.fov/2 + rayStep * i;
                const distance = castRay(rayAngle);
                const wallHeight = canvas.height / distance;
                
                // Wall color based on player health
                const healthFactor = state.player.health / state.player.maxHealth;
                const redIntensity = Math.min(255, (255/distance) + (1-healthFactor) * 255);
                const otherColors = (255/distance) * healthFactor;
                ctx.fillStyle = `rgb(${redIntensity}, ${otherColors}, ${otherColors})`;
                ctx.fillRect(i, (canvas.height-wallHeight)/2, 1, wallHeight);

                // Draw player arms
                if (i === Math.floor(canvas.width * 0.3) || i === Math.floor(canvas.width * 0.7)) {
                    const armSwing = Math.sin(player.arms.swingOffset) * 20;
                    ctx.fillStyle = '#8B4513';  // Brown color for arms
                    ctx.fillRect(i, canvas.height - 100 + armSwing, 10, 100);
                }

                // Draw health HUD
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(10, 10, 200 * (state.player.health / state.player.maxHealth), 20);
                ctx.strokeStyle = '#ffffff';
                ctx.strokeRect(10, 10, 200, 20);
            }
            
            // Update arm swing animation
            if (keys.w || keys.s) {
                player.arms.swingOffset += player.arms.swingSpeed;
            }

            updateEntities();
            requestAnimationFrame(drawFrame);
        }

        // Input handling
        // Create falling flame emojis
        function createFlame() {
            const flame = document.createElement('div');
            flame.className = 'flame';
            flame.textContent = Math.random() > 0.5 ? '🔥' : '🥟';
            flame.style.left = Math.random() * 100 + 'vw';
            flame.style.animationDuration = Math.random() * 3 + 2 + 's';
            document.getElementById('flameContainer').appendChild(flame);
            flame.addEventListener('animationend', () => flame.remove());
        }
        setInterval(createFlame, 500);

        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
                // Disable autoplay on any key press
                state.autoplay.enabled = false;
                state.autoplay.lastActivity = Date.now();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
                state.autoplay.lastActivity = Date.now();
            }
        });

        drawFrame();
    </script>
</body>
</html>
