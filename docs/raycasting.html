<!DOCTYPE html>
<html>
<head>
    <title>DEEZ NUTS RAYCASTER</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
        }
        canvas { 
            grid-column: 2 / 12;
            grid-row: 2;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .flame-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .flame {
            position: absolute;
            font-size: 24px;
            animation: fall linear infinite;
        }
        @keyframes fall {
            from { transform: translateY(-20px); }
            to { transform: translateY(100vh); }
        }
        .game-title {
            grid-column: 1 / -1;
            grid-row: 1;
            text-align: center;
            color: #ff4400;
            font-size: 48px;
            text-shadow: 0 0 10px #ff0000;
            z-index: 2;
        }
    .ceo-approval {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 2;
            text-align: center;
            color: #ff4400;
            text-shadow: 0 0 10px #ff0000;
        }
        .ceo-approval img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid #ff4400;
            box-shadow: 0 0 10px #ff0000;
        }
    </style>
</head>
<body>
    <h1 class="game-title">ðŸ”¥ CHUSSY DEEZ NUTS INFERNO 3D ðŸ”¥</h1>
    <div class="flame-container" id="flameContainer"></div>
    <canvas id="gameCanvas"></canvas>
    <div class="ceo-approval">
        <p>I approve of this webpage</p>
        <img src="https://avatars.githubusercontent.com/u/4442245" alt="ThePrimeagen CEO">
    </div>
    <script>
        // Key state tracking
        const keys = {
            w: false,
            s: false,
            a: false,
            d: false,
            ' ': false
        };

        // Game state
        const state = {
            projectiles: [],
            enemies: [],
            lastShot: 0,
            shootCooldown: 250 // milliseconds
        };

        // Map data
        const MAP = [
            [1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1],
            [1,0,1,0,0,1,0,1],
            [1,0,0,0,0,0,0,1],
            [1,0,1,0,0,1,0,1],
            [1,0,0,0,0,0,0,1],
            [1,0,1,0,0,1,0,1],
            [1,1,1,1,1,1,1,1]
        ];

        // Player state
        const player = {
            x: 1.5,
            y: 1.5,
            angle: 0,
            fov: Math.PI / 3,
            speed: 0.1
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Raycasting
        function castRay(rayAngle) {
            let rayX = player.x;
            let rayY = player.y;
            let rayDirX = Math.cos(rayAngle);
            let rayDirY = Math.sin(rayAngle);
            
            let distance = 0;
            while (distance < 20) {
                rayX += rayDirX * 0.1;
                rayY += rayDirY * 0.1;
                distance += 0.1;
                
                let mapX = Math.floor(rayX);
                let mapY = Math.floor(rayY);
                
                if (MAP[mapY] && MAP[mapY][mapX] === 1) {
                    return distance;
                }
            }
            return distance;
        }

        // Spawn enemies
        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 5;
            state.enemies.push({
                x: player.x + Math.cos(angle) * distance,
                y: player.y + Math.sin(angle) * distance,
                health: 100
            });
        }
        setInterval(spawnEnemy, 5000);

        // Shooting mechanics
        function shoot() {
            const now = Date.now();
            if (now - state.lastShot >= state.shootCooldown) {
                state.projectiles.push({
                    x: player.x,
                    y: player.y,
                    angle: player.angle,
                    speed: 0.5
                });
                state.lastShot = now;
            }
        }

        // Update projectiles and enemies
        function updateEntities() {
            // Handle continuous movement
            if (keys.w) {
                player.x += Math.cos(player.angle) * player.speed;
                player.y += Math.sin(player.angle) * player.speed;
            }
            if (keys.s) {
                player.x -= Math.cos(player.angle) * player.speed;
                player.y -= Math.sin(player.angle) * player.speed;
            }
            if (keys.a) {
                player.angle -= 0.1;
            }
            if (keys.d) {
                player.angle += 0.1;
            }

            // Handle shooting
            if (keys[' ']) {
                shoot();
            }

            // Update projectiles
            for (let i = state.projectiles.length - 1; i >= 0; i--) {
                const proj = state.projectiles[i];
                proj.x += Math.cos(proj.angle) * proj.speed;
                proj.y += Math.sin(proj.angle) * proj.speed;
                
                // Check collision with walls
                if (MAP[Math.floor(proj.y)][Math.floor(proj.x)] === 1) {
                    state.projectiles.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = state.enemies.length - 1; j >= 0; j--) {
                    const enemy = state.enemies[j];
                    const dx = proj.x - enemy.x;
                    const dy = proj.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.5) {
                        enemy.health -= 50;
                        if (enemy.health <= 0) {
                            state.enemies.splice(j, 1);
                        }
                        state.projectiles.splice(i, 1);
                        break;
                    }
                }
            }

            // Update enemies
            state.enemies.forEach(enemy => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.1) {
                    enemy.x += (dx / dist) * 0.03;
                    enemy.y += (dy / dist) * 0.03;
                }
            });
        }

        function drawFrame() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const numRays = canvas.width;
            const rayStep = player.fov / numRays;
            
            for (let i = 0; i < numRays; i++) {
                const rayAngle = player.angle - player.fov/2 + rayStep * i;
                const distance = castRay(rayAngle);
                const wallHeight = canvas.height / distance;
                
                ctx.fillStyle = `rgb(${255/distance}, ${255/distance}, ${255/distance})`;
                ctx.fillRect(i, (canvas.height-wallHeight)/2, 1, wallHeight);
            }
            
            updateEntities();
            requestAnimationFrame(drawFrame);
        }

        // Input handling
        // Create falling flame emojis
        function createFlame() {
            const flame = document.createElement('div');
            flame.className = 'flame';
            flame.textContent = 'ðŸ”¥';
            flame.style.left = Math.random() * 100 + 'vw';
            flame.style.animationDuration = Math.random() * 3 + 2 + 's';
            document.getElementById('flameContainer').appendChild(flame);
            flame.addEventListener('animationend', () => flame.remove());
        }
        setInterval(createFlame, 500);

        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
        });

        drawFrame();
    </script>
</body>
</html>
